#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sweep Runner for TRINITY
========================

Parallel execution engine for parameter sweeps.

Features:
- Run simulations in parallel batches using ProcessPoolExecutor
- Progress bar with completed/total, percentage, and ETA
- Continue on failure, collect and report all errors at end
- Generate human-readable and JSON reports

Author: Claude Code
Date: 2026-01-14
"""

import json
import os
import sys
import shutil
import subprocess
import time
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


# =============================================================================
# Data Classes
# =============================================================================

@dataclass
class SimulationResult:
    """Result of a single simulation run."""
    name: str
    params: Dict[str, Any]
    success: bool
    return_code: int
    duration: float
    error_message: Optional[str] = None
    output_path: Optional[str] = None


@dataclass
class SweepProgress:
    """Track progress of parameter sweep."""
    total: int
    completed: int = 0
    succeeded: int = 0
    failed: int = 0
    start_time: Optional[datetime] = None

    def elapsed(self) -> timedelta:
        if self.start_time is None:
            return timedelta(0)
        return datetime.now() - self.start_time

    def eta(self) -> Optional[timedelta]:
        if self.completed == 0:
            return None
        elapsed_seconds = self.elapsed().total_seconds()
        if elapsed_seconds == 0:
            return None
        rate = self.completed / elapsed_seconds
        remaining = self.total - self.completed
        return timedelta(seconds=remaining / rate)


# =============================================================================
# Parameter File Generation
# =============================================================================

def generate_param_file(
    params: Dict[str, Any],
    run_name: str,
    base_output_dir: str
) -> str:
    """
    Generate parameter file content for a single simulation.

    Parameters
    ----------
    params : dict
        Parameter dictionary for this simulation
    run_name : str
        Name for this run (e.g., '1e5_sfe001_n1e2')
    base_output_dir : str
        Base output directory from sweep file

    Returns
    -------
    str
        Content for .param file
    """
    lines = [
        f"# Auto-generated by run_sweep.py",
        f"# Run: {run_name}",
        f"# Generated: {datetime.now().isoformat()}",
        "",
        f"model_name    {run_name}",
        f"path2output    {base_output_dir}",
    ]

    for key, value in params.items():
        # Skip keys we've already handled
        if key in ('model_name', 'path2output'):
            continue

        # Format value appropriately
        if isinstance(value, bool):
            val_str = str(value)
        elif isinstance(value, float):
            # Use scientific notation for large/small numbers
            if abs(value) >= 1e4 or (abs(value) < 0.01 and value != 0):
                val_str = f"{value:.6g}"
            else:
                val_str = str(value)
        else:
            val_str = str(value)

        lines.append(f"{key}    {val_str}")

    return '\n'.join(lines) + '\n'


# =============================================================================
# Single Simulation Execution
# =============================================================================

def run_single_simulation(
    params: Dict[str, Any],
    run_name: str,
    trinity_root: Path,
    base_output_dir: str,
    timeout_hours: float = 24.0
) -> SimulationResult:
    """
    Execute a single TRINITY simulation.

    Creates a parameter file and runs `python run.py <param_file>`

    Parameters
    ----------
    params : dict
        Parameter dictionary for this simulation
    run_name : str
        Name for this run
    trinity_root : Path
        Path to TRINITY root directory
    base_output_dir : str
        Base output directory
    timeout_hours : float
        Timeout in hours (default: 24)

    Returns
    -------
    SimulationResult
        Result of the simulation
    """
    start_time = time.time()

    # Create output directory for this run
    output_dir = Path(base_output_dir) / run_name
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create parameter file in the output directory
    param_content = generate_param_file(params, run_name, base_output_dir)
    param_path = output_dir / f"{run_name}.param"

    try:
        with open(param_path, 'w', encoding='utf-8') as f:
            f.write(param_content)
    except Exception as e:
        return SimulationResult(
            name=run_name,
            params=params,
            success=False,
            return_code=-1,
            duration=time.time() - start_time,
            error_message=f"Failed to write param file: {e}",
            output_path=str(output_dir)
        )

    # Run simulation
    try:
        result = subprocess.run(
            [sys.executable, str(trinity_root / 'run.py'), str(param_path)],
            cwd=str(trinity_root),
            capture_output=True,
            text=True,
            timeout=timeout_hours * 3600
        )

        duration = time.time() - start_time

        if result.returncode == 0:
            return SimulationResult(
                name=run_name,
                params=params,
                success=True,
                return_code=0,
                duration=duration,
                output_path=str(output_dir)
            )
        else:
            # Extract last portion of stderr for error message
            stderr = result.stderr[-2000:] if result.stderr else ""
            stdout_tail = result.stdout[-500:] if result.stdout else ""
            error_msg = stderr or stdout_tail or "Unknown error (no output)"

            return SimulationResult(
                name=run_name,
                params=params,
                success=False,
                return_code=result.returncode,
                duration=duration,
                error_message=error_msg,
                output_path=str(output_dir)
            )

    except subprocess.TimeoutExpired:
        duration = time.time() - start_time
        return SimulationResult(
            name=run_name,
            params=params,
            success=False,
            return_code=-1,
            duration=duration,
            error_message=f"Simulation timed out ({timeout_hours}h limit)",
            output_path=str(output_dir)
        )
    except Exception as e:
        duration = time.time() - start_time
        return SimulationResult(
            name=run_name,
            params=params,
            success=False,
            return_code=-1,
            duration=duration,
            error_message=str(e),
            output_path=str(output_dir)
        )


# =============================================================================
# Progress Bar
# =============================================================================

class ProgressBar:
    """
    Progress bar with fallback if tqdm not available.

    Features:
    - Completed/Total count
    - Percentage
    - Elapsed time
    - ETA
    - Current simulation name
    """

    def __init__(self, total: int, desc: str = "Sweep"):
        self.total = total
        self.completed = 0
        self.succeeded = 0
        self.failed = 0
        self.desc = desc
        self.start_time = datetime.now()
        self.current_name = ""
        self.terminal_width = shutil.get_terminal_size().columns

        # Try to use tqdm if available
        self._tqdm = None
        try:
            from tqdm import tqdm
            self._tqdm = tqdm(total=total, desc=desc, unit="sim")
        except ImportError:
            logger.info("tqdm not installed, using simple progress display")

    def update(self, name: str, success: bool):
        """Update progress after a simulation completes."""
        self.completed += 1
        if success:
            self.succeeded += 1
        else:
            self.failed += 1
        self.current_name = name

        if self._tqdm:
            self._tqdm.update(1)
            self._tqdm.set_postfix({
                'ok': self.succeeded,
                'fail': self.failed,
            })
        else:
            self._print_progress()

    def set_running(self, names: List[str]):
        """Show currently running simulations."""
        if not self._tqdm:
            running_str = ", ".join(names[:3])
            if len(names) > 3:
                running_str += f" (+{len(names)-3} more)"
            print(f"  Running: {running_str}")

    def _print_progress(self):
        """Print progress bar to terminal."""
        pct = 100 * self.completed / self.total if self.total > 0 else 0
        elapsed = datetime.now() - self.start_time

        # Calculate ETA
        if self.completed > 0:
            rate = self.completed / elapsed.total_seconds()
            remaining = self.total - self.completed
            eta_seconds = remaining / rate if rate > 0 else 0
            eta_str = str(timedelta(seconds=int(eta_seconds)))
        else:
            eta_str = "calculating..."

        # Build progress bar
        bar_width = min(30, self.terminal_width - 70)
        filled = int(bar_width * self.completed / self.total) if self.total > 0 else 0
        bar = '=' * filled + '>' + '.' * max(0, bar_width - filled - 1)

        elapsed_str = str(timedelta(seconds=int(elapsed.total_seconds())))

        status = f"\r{self.desc}: [{bar}] {self.completed}/{self.total} ({pct:.1f}%) "
        status += f"| OK:{self.succeeded} FAIL:{self.failed} "
        status += f"| Elapsed: {elapsed_str} | ETA: {eta_str}"

        # Truncate or pad to terminal width
        if len(status) > self.terminal_width - 1:
            status = status[:self.terminal_width - 4] + "..."
        else:
            status = status.ljust(self.terminal_width - 1)

        sys.stdout.write(status)
        sys.stdout.flush()

    def close(self):
        """Clean up progress display."""
        if self._tqdm:
            self._tqdm.close()
        else:
            print()  # New line after progress bar

    def summary(self) -> str:
        """Generate summary string."""
        elapsed = datetime.now() - self.start_time
        avg_time = elapsed / self.total if self.total > 0 else timedelta(0)

        lines = [
            "",
            "=" * 60,
            "SWEEP COMPLETE",
            "=" * 60,
            f"Total simulations: {self.total}",
            f"Succeeded: {self.succeeded}",
            f"Failed: {self.failed}",
            f"Total time: {elapsed}",
            f"Avg time per simulation: {avg_time}",
            "=" * 60,
        ]
        return '\n'.join(lines)


# =============================================================================
# Sweep Report
# =============================================================================

@dataclass
class SweepReport:
    """Complete report of a parameter sweep."""
    sweep_file: str
    start_time: datetime
    end_time: datetime
    total_combinations: int
    successful: List[SimulationResult] = field(default_factory=list)
    failed: List[SimulationResult] = field(default_factory=list)

    def write_report(self, output_path: Path) -> Path:
        """Write detailed human-readable report to file."""
        report_path = output_path / "sweep_report.txt"

        with open(report_path, 'w', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write("TRINITY PARAMETER SWEEP REPORT\n")
            f.write("=" * 80 + "\n\n")

            f.write(f"Sweep file: {self.sweep_file}\n")
            f.write(f"Start time: {self.start_time}\n")
            f.write(f"End time: {self.end_time}\n")
            f.write(f"Duration: {self.end_time - self.start_time}\n\n")

            f.write(f"Total combinations: {self.total_combinations}\n")
            f.write(f"Successful: {len(self.successful)}\n")
            f.write(f"Failed: {len(self.failed)}\n\n")

            if self.failed:
                f.write("-" * 80 + "\n")
                f.write("FAILED SIMULATIONS\n")
                f.write("-" * 80 + "\n\n")

                for result in self.failed:
                    f.write(f"Name: {result.name}\n")
                    f.write(f"Return code: {result.return_code}\n")
                    f.write(f"Duration: {result.duration:.2f}s\n")
                    f.write(f"Output: {result.output_path}\n")
                    f.write(f"Error:\n")
                    # Indent error message
                    error_lines = (result.error_message or "Unknown").split('\n')
                    for line in error_lines[-20:]:  # Last 20 lines
                        f.write(f"  {line}\n")
                    f.write(f"Parameters:\n")
                    for k, v in result.params.items():
                        f.write(f"  {k}: {v}\n")
                    f.write("\n")

            if self.successful:
                f.write("-" * 80 + "\n")
                f.write("SUCCESSFUL SIMULATIONS\n")
                f.write("-" * 80 + "\n\n")

                for result in self.successful:
                    f.write(f"{result.name}: {result.duration:.2f}s -> {result.output_path}\n")

        return report_path

    def write_json(self, output_path: Path) -> Path:
        """Write machine-readable JSON report."""
        report_path = output_path / "sweep_report.json"

        data = {
            'sweep_file': self.sweep_file,
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat(),
            'duration_seconds': (self.end_time - self.start_time).total_seconds(),
            'total': self.total_combinations,
            'succeeded': len(self.successful),
            'failed': len(self.failed),
            'results': [
                {
                    'name': r.name,
                    'success': r.success,
                    'return_code': r.return_code,
                    'duration': r.duration,
                    'error': r.error_message,
                    'output_path': r.output_path,
                    'params': r.params
                }
                for r in self.successful + self.failed
            ]
        }

        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2)

        return report_path


# =============================================================================
# Testing
# =============================================================================

if __name__ == "__main__":
    # Quick test
    logging.basicConfig(level=logging.DEBUG)

    # Test progress bar
    print("Testing ProgressBar:")
    progress = ProgressBar(10, "Test")
    for i in range(10):
        time.sleep(0.1)
        progress.update(f"test_{i}", success=(i % 3 != 0))
    progress.close()
    print(progress.summary())

    print("\nAll tests complete!")
